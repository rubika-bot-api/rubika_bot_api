Metadata-Version: 2.4
Name: rubika-bot-api
Version: 1.0.2
Summary: A powerful asynchronous/synchronous library for Rubika Bot API with a focus on high performance.
Author-email: rubika api bot <0x01101101@proton.me>
License-Expression: MIT
Project-URL: Homepage, https://github.com/rubika-bot-api/rubika_bot_api
Project-URL: Bug Tracker, https://github.com/rubika-bot-api/rubika_bot_api/issues
Project-URL: Documentation, https://github.com/rubika-bot-api/rubika_bot_api/blob/main/README.md
Classifier: Programming Language :: Python :: 3
Classifier: Operating System :: OS Independent
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Communications :: Chat
Classifier: Topic :: Internet
Classifier: Topic :: Software Development :: Libraries
Classifier: Framework :: AsyncIO
Requires-Python: >=3.7
Description-Content-Type: text/markdown
License-File: LICENCE
Requires-Dist: aiohttp
Requires-Dist: aiofiles
Requires-Dist: requests
Requires-Dist: pytz
Dynamic: license-file

# ğŸ¤– Rubika Bot API Library ğŸš€

A powerful asynchronous/synchronous library for Rubika Bot API with a focus on high performance.

## âœ¨ About

`rubika-bot-api` is a comprehensive Python library designed to simplify interaction with the Rubika messaging platform's Bot API. It seamlessly supports both asynchronous (`async/await`) and synchronous (`requests`) operations, offering unparalleled versatility for diverse project requirements. Engineered for speed and reliability, it's the perfect foundation for building high-performance, robust, and extensible bots.

## ğŸŒŸ Key Features

-   **Dual Mode Support**: Effortlessly switch between non-blocking asynchronous (`async/await`) and traditional blocking synchronous API calls.
-   **Blazing Fast Performance**: Optimized for concurrent message processing, crucial for bots handling high volumes of messages across multiple groups.
-   **Persistent Offset Handling**: Ensures message continuity, preventing data loss and redundant processing even after bot restarts.
-   **Dynamic Keyboard Management**: Create sophisticated inline keyboards and reply keyboards for rich user interaction.
-   **Robust Anti-Spam System**: Safeguard your bot from message floods with configurable thresholds and persistent user blocking.
-   **Extensive API Coverage**: Full support for sending various message types (text, photos, videos, documents, stickers) and comprehensive keypad management.
-   **Modular & Clean Architecture**: Designed with a focus on modularity, ensuring easy extensibility and maintainability for your custom bot logic.


## â¬‡ï¸ Installation

You can install `rubika-bot-api` using pip:

```bash
pip install rubika-bot-api
```

## âš¡ Quick Start & Usage Examples
#### Let's dive into how you can use rubika-bot-api to build your bot.

- âš™ï¸ Synchronous Bot Example

    - For simpler tasks or environments where asynchronous programming is not a strict requirement, you can use the synchronous methods.
```python
import time
from rubika_bot_api.api import Robot # Ensure rubika_bot_api is installed or in PYTHONPATH
from rubika_bot_api.filters import text, command # Assuming you have filters module

# --- Configuration ---
RUBIKA_TOKEN = "YOUR_RUBIKA_BOT_TOKEN" # Replace with your actual token
bot = Robot(token=RUBIKA_TOKEN)

# --- Message Handler ---
@bot.on_message(filters=text & command("hello_sync"))
def hello_sync_handler(robot, message):
    """Responds to /hello_sync command synchronously."""
    print(f"Received sync message: {message.text} from {message.sender_id}")
    response_text = "Hello from your synchronous Rubika bot!"
    
    # Using synchronous send_message_sync
    robot.send_message_sync(
        chat_id=message.chat_id,
        text=response_text
    )

# --- Run the Bot ---
if __name__ == "__main__":
    print("Running synchronous Rubika bot (polling)...")
    # In synchronous mode, the bot.run() method handles the polling loop.
    # It will process updates one by one.
    bot.run()
```
---
- ğŸš€ Asynchronous Bot Example
    - For high-performance, responsive bots capable of handling many users and long-running tasks concurrently (like AI responses), the asynchronous mode is highly recommended. This example shows an AI bot with inline keyboard interaction.

```python
import asyncio
from rubika_bot_api.api import Robot
from rubika_bot_api.filters import text

# --- Configuration ---
RUBIKA_TOKEN = "YOUR_RUBIKA_BOT_TOKEN" # Replace with your actual token
bot = Robot(token=RUBIKA_TOKEN)

# --- Message Handler (Async function using Sync API call) ---
@bot.on_message(filters=text)
async def handle_sync_api_call(bot, message):
    """
    Handles text messages. 
    Demonstrates making a SYNCHRONOUS API call within an ASYNCHRONOUS handler.
    """
    print(f"Received message: '{message.text}' from {message.sender_id}")
    
    # Example: Send a message SYNCHRONOUSLY
    # Note: This will block the current task until the request completes.
    sync_response = bot.send_message_sync(
        chat_id=message.chat_id,
        text=f"Sync API says: You typed '{message.text}'"
    )
    print(f"Sync API call result: {sync_response}")

    # You can also get bot info synchronously
    me_info = bot.get_me_sync()
    print(f"My sync bot ID: {me_info.get('data', {}).get('bot_id')}")

# --- Run the Bot ---
if __name__ == "__main__":
    print("Starting Rubika bot with synchronous API call example...")
    # The bot's main loop is still asynchronous.
    asyncio.run(bot.run())
```
---
- ğŸš€ Asynchronous Bot Example
    - For high-performance, responsive bots capable of handling many users and long-running tasks concurrently, the asynchronous mode is highly recommended. This example shows a basic asynchronous bot echoing messages and responding to a start command.

```python
import asyncio
from rubika_bot_api.api import Robot
from rubika_bot_api import filters
from rubika_bot_api.keyboards import ChatKeyboardBuilder

# --- Configuration ---
RUBIKA_TOKEN = "YOUR_RUBIKA_BOT_TOKEN" # Replace with your actual token
bot = Robot(token=RUBIKA_TOKEN)

# --- Bot Start Handler ---
@bot.on_started_bot()
async def on_bot_start(bot, chat_id):
    """Sends a welcome message when a user starts the bot."""
    await bot.send_message(chat_id, "Hello! Welcome to the bot. Send me a message.")

# --- Main Message Handler ---
@bot.on_message(filters=filters.pv) # Only process messages in private chats
async def on_new_message(bot, message_context):
    """Responds to text messages or handles the '/start' command (typed or button click)."""
    
    # Handle the '/start' command (typed text)
    if message_context.text == "/start":
        start_keyboard = ChatKeyboardBuilder(resize=True, on_time=False).row("Start Bot").build()
        await message_context.reply(
            "Welcome! I am your Rubika bot. Send me any text.",
            chat_keypad=start_keyboard,
            chat_keypad_type="New"
        )
        return

    # Handle 'Start Bot' button click (from reply keyboard)
    if message_context.aux_data and message_context.aux_data.button_id == "Start Bot":
        await message_context.reply("Bot is ready. Please send your message.")
        return

    # Echo any other text message
    if filters.text(message_context):
        response_text = f"You said (async): '{message_context.text}'"
        await message_context.reply(response_text)
    
    # Handle other message types if needed (e.g., photos, videos)
    elif filters.photo(message_context):
        await message_context.reply("I received a photo!")

# --- Run the Bot ---
if __name__ == "__main__":
    print("Starting asynchronous Rubika bot...")
    asyncio.run(bot.run())
```
---
### ğŸ›¡ï¸ Simple Anti-Spam Example

Integrate the built-in anti-spam manager to protect your bot from message floods.

```python
import asyncio
from rubika_bot_api.api import Robot
from rubika_bot_api import filters
from rubika_bot_api.antispam import AntiSpamManager

# --- Configuration ---
RUBIKA_TOKEN = "YOUR_RUBIKA_BOT_TOKEN" 
bot = Robot(token=RUBIKA_TOKEN)
spam_manager = AntiSpamManager(spam_threshold=3, time_window=10, punishment_duration=60) # 3 messages in 10s -> 60s block

# --- Message Handler ---
@bot.on_message(filters=filters.pv) # Process private messages only
async def anti_spam_check_handler(bot_instance, message_context):
    user_id = message_context.sender_id
    
    # Check if user is currently punished (from previous spamming)
    if spam_manager.is_punished(user_id):
        print(f"Anti-spam: User {user_id} is still punished. Ignoring.")
        return # Ignore message from punished users
    
    # Check if this message triggers a new punishment
    if spam_manager.check_and_punish(user_id):
        await message_context.reply("ğŸš« **Ø§Ø³Ù¾Ù… Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯!** Ø´Ù…Ø§ Ù…ÙˆÙ‚ØªØ§Ù‹ Ø¨Ù‡ Ù…Ø¯Øª 1 Ø¯Ù‚ÛŒÙ‚Ù‡ Ù…Ø³Ø¯ÙˆØ¯ Ø´Ø¯ÛŒØ¯.")
        print(f"Anti-spam: User {user_id} triggered spam, now punished.")
        return # Block further processing for this message

    # If not spammed, process the message normally
    if filters.text(message_context):
        await message_context.reply(f"Ù¾ÛŒØ§Ù… Ø´Ù…Ø§: '{message_context.text}' (Ø¶Ø¯ Ø§Ø³Ù¾Ù… ÙØ¹Ø§Ù„)")

# --- Run the Bot ---
if __name__ == "__main__":
    print("Running anti-spam example bot...")
    asyncio.run(bot.run())
```
---

### âŒ¨ï¸ Simple Inline Keyboard (Glass Button) Example

##### Learn to create inline keyboards and handle button clicks in your bot's messages.

```python
import asyncio
from rubika_bot_api.api import Robot
from rubika_bot_api import filters
from rubika_bot_api.keyboards import InlineKeyboardBuilder # Required for inline keyboards

# --- Configuration ---
RUBIKA_TOKEN = "YOUR_RUBIKA_BOT_TOKEN" 
bot = Robot(token=RUBIKA_TOKEN)

# --- Keyboard Builder ---
def create_action_keyboard(message_id_for_button: str) -> dict:
    """Builds an inline keyboard with a simple action button."""
    
    # Define a single glass button
    action_button = InlineKeyboardBuilder.button(
        text="ğŸ‘‡ Ø±ÙˆÛŒ Ù…Ù† Ú©Ù„ÛŒÚ© Ú©Ù†! ğŸ‘‡",
        button_id=f"my_unique_action_{message_id_for_button}" # Unique ID for this button
    )
    
    # Build the keyboard with one row
    keyboard = InlineKeyboardBuilder().row(action_button).build()
    return keyboard

# --- Message Handler ---
@bot.on_message(filters=filters.pv & filters.text) # Process private text messages
async def inline_keyboard_example_handler(bot_instance, message_context):
    # Check if this is a button click first
    if message_context.aux_data and message_context.aux_data.button_id:
        button_id = message_context.aux_data.button_id
        
        if button_id.startswith("my_unique_action_"):
            # Acknowledge the click by editing the message
            await bot_instance.edit_message_text(
                chat_id=message_context.chat_id,
                message_id=message_context.message_id,
                text="âœ… Ø¯Ú©Ù…Ù‡ Ú©Ù„ÛŒÚ© Ø´Ø¯! Ø¹Ù…Ù„ÛŒØ§Øª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯."
            )
            return
        
        # Add a fallback for unhandled buttons (important for robustness)
        await message_context.reply(f"â‰ï¸ Ø¯Ú©Ù…Ù‡ Ù†Ø§Ø´Ù†Ø§Ø®ØªÙ‡ Ú©Ù„ÛŒÚ© Ø´Ø¯: {button_id}")
        return

    # If it's not a button click, send a new message with the keyboard
    example_keyboard = create_action_keyboard(message_context.message_id) # Use message ID for unique button
    await message_context.reply(
        text="Ø§ÛŒÙ† ÛŒÚ© Ù¾ÛŒØ§Ù… Ø¨Ø§ Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø§ÛŒÙ†Ù„Ø§ÛŒÙ† Ø§Ø³Øª. Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯:",
        inline_keypad=example_keyboard
    )

# --- Run the Bot ---
if __name__ == "__main__":
    print("Running inline keyboard example bot...")
    asyncio.run(bot.run())
```
---

### ğŸ” Simple Debugging Bot Example

A minimalist bot that prints all received message details and raw data to the console for quick debugging.

```python
import asyncio
import json # Required for pretty-printing raw data
from rubika_bot_api.api import Robot # Main bot library import

# --- Configuration ---
RUBIKA_TOKEN = "YOUR_RUBIKA_BOT_TOKEN" # Replace with your actual token
bot = Robot(token=RUBIKA_TOKEN)

# --- Message Handler ---
@bot.on_message() # This handler receives ALL NewMessage updates (no filters applied here)
async def debug_message_printer(bot_instance, message_context):
    print("\n" + "="*50)
    print(">>> RECEIVED MESSAGE FOR DEBUGGING <<<")
    print("="*50)
    
    # Print key message attributes
    print(f"  Message ID: {message_context.message_id}")
    print(f"  Chat ID: {message_context.chat_id}")
    print(f"  Sender ID: {message_context.sender_id}")
    print(f"  Message Text: {message_context.text}")
    print(f"  Chat Type: {message_context.chat_type}")
    print(f"  Is Edited: {message_context.is_edited}")
    
    # Print presence of common objects (aux_data, file, etc.)
    print(f"  Has Aux Data (Button Click Info): {'Yes' if message_context.aux_data else 'No'}")
    print(f"  Has File Data: {'Yes' if message_context.file else 'No'}")
    print(f"  Has Sticker Data: {'Yes' if message_context.sticker else 'No'}")

    print("\n--- RAW DATA (Full JSON from Rubika API) ---")
    # Pretty print the full raw data received from Rubika API
    print(json.dumps(message_context.raw_data, indent=2, ensure_ascii=False))
    print("="*50 + "\n")

    # Send a simple reply to confirm message receipt
    await message_context.reply("âœ… Ø¬Ø²Ø¦ÛŒØ§Øª Ù¾ÛŒØ§Ù… Ø´Ù…Ø§ Ø¯Ø± Ú©Ù†Ø³ÙˆÙ„ Ù¾Ø±ÛŒÙ†Øª Ø´Ø¯!")

# --- Run the Bot ---
if __name__ == "__main__":
    print("Starting Rubika Debugging Bot...")
    # This runs the bot's asynchronous event loop
    asyncio.run(bot.run())
```
---
### ğŸš€ Basic Bot Example 

This concise example demonstrates message handling, basic filtering, logging, and sending inline keyboards (glass buttons).

```python
import asyncio
from rubika_bot_api.api import Robot
from rubika_bot_api import filters
from rubika_bot_api.keyboards import InlineKeyboardBuilder
from rubika_bot_api.logger import logger, debugging

# --- Configuration ---
RUBIKA_TOKEN = "YOUR_RUBIKA_BOT_TOKEN" 
debugging(True) # Enable logging for this example

# --- Bot Initialization ---
bot = Robot(token=RUBIKA_TOKEN)

# --- Message Handler ---
@bot.on_message(filters=filters.pv & filters.text) # Only private text messages
async def handle_message_and_button(bot_instance, message_context):
    logger.info(f"Received text from PV: '{message_context.text}'")

    # Handle a specific command or simple text
    if message_context.text == "/greet":
        # Create a simple inline (glass) button
        my_button = InlineKeyboardBuilder.button(
            text="ğŸ‘‹ Ø³Ù„Ø§Ù… Ú©Ù†",
            button_id="greet_button_clicked"
        )
        keyboard = InlineKeyboardBuilder().row(my_button).build()
        
        await message_context.reply(
            "Ù„Ø·ÙØ§ Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯:",
            inline_keypad=keyboard
        )
        logger.info("Sent message with inline button.")
        return
    
    # Handle the inline button click
    if message_context.aux_data and message_context.aux_data.button_id == "greet_button_clicked":
        await bot_instance.edit_message_text(
            chat_id=message_context.chat_id,
            message_id=message_context.message_id,
            text="âœ… Ø³Ù„Ø§Ù… Ø±Ø¨Ø§Øª! Ø¯Ú©Ù…Ù‡ Ú©Ù„ÛŒÚ© Ø´Ø¯."
        )
        logger.info("Handled inline button click: 'greet_button_clicked'")
        return

    # Default echo for other text messages
    response_text = f"Ø´Ù…Ø§ Ú¯ÙØªÛŒØ¯: '{message_context.text}'"
    await message_context.reply(response_text)
    logger.info(f"Echoed message: '{response_text}'")

# --- Run the Bot ---
if __name__ == "__main__":
    logger.info("Starting a concise Rubika bot example...")
    asyncio.run(bot.run())

```

---

```python
### âŒ¨ï¸ Simple Reply Keyboard Example

Learn how to create and display a basic Reply Keyboard (Chat Keyboard) at the bottom of the chat screen, similar to the default `/start` button.

```python
import asyncio
from rubika_bot_api.api import Robot
from rubika_bot_api import filters
from rubika_bot_api.keyboards import ChatKeyboardBuilder # Required for Reply Keyboards
from rubika_bot_api.logger import logger, debugging

# --- Configuration ---
RUBIKA_TOKEN = "YOUR_RUBIKA_BOT_TOKEN" 
debugging(True) # Enable logging for this example

# --- Bot Initialization ---
bot = Robot(token=RUBIKA_TOKEN)

# --- Keyboard Builder ---
def create_simple_reply_keyboard() -> dict:
    """Creates a simple Reply Keyboard with a few buttons."""
    return ChatKeyboardBuilder(resize=True, on_time=False) \
           .row("Ú¯Ø²ÛŒÙ†Ù‡ Û±", "Ú¯Ø²ÛŒÙ†Ù‡ Û²") \
           .row("Ø¨Ø³ØªÙ† Ú©ÛŒØ¨ÙˆØ±Ø¯") \
           .build()

# --- Message Handler ---
@bot.on_message(filters=filters.pv & filters.text) # Process private text messages
async def handle_reply_keyboard(bot_instance, message_context):
    logger.info(f"Received text from PV: '{message_context.text}'")

    # Command to show the keyboard
    if message_context.text == "/show_keyboard":
        reply_keyboard = create_simple_reply_keyboard()
        await message_context.reply(
            "Ù„Ø·ÙØ§ Ø§Ø² Ú©ÛŒØ¨ÙˆØ±Ø¯ Ù¾Ø§ÛŒÛŒÙ† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯:",
            chat_keypad=reply_keyboard,
            chat_keypad_type="New" # "New" shows the keyboard
        )
        logger.info("Sent message with Reply Keyboard.")
        return
    
    # Command to hide the keyboard
    elif message_context.text == "/hide_keyboard":
        await message_context.reply(
            "Ú©ÛŒØ¨ÙˆØ±Ø¯ Ù¾Ù†Ù‡Ø§Ù† Ø´Ø¯.",
            chat_keypad_type="Removed" # "Removed" hides the keyboard
        )
        logger.info("Hidden Reply Keyboard.")
        return

    # Handle clicks on the reply keyboard buttons
    # Note: Reply keyboard button clicks send the button's text as a normal message.
    # So, we check message.text directly.
    elif message_context.text == "Ú¯Ø²ÛŒÙ†Ù‡ Û±":
        await message_context.reply("Ø´Ù…Ø§ Ú¯Ø²ÛŒÙ†Ù‡ Û± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯ÛŒØ¯.")
        logger.info("Handled 'Ú¯Ø²ÛŒÙ†Ù‡ Û±' click.")
        return
    
    elif message_context.text == "Ú¯Ø²ÛŒÙ†Ù‡ Û²":
        await message_context.reply("Ø´Ù…Ø§ Ú¯Ø²ÛŒÙ†Ù‡ Û² Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯ÛŒØ¯.")
        logger.info("Handled 'Ú¯Ø²ÛŒÙ†Ù‡ Û²' click.")
        return

    elif message_context.text == "Ø¨Ø³ØªÙ† Ú©ÛŒØ¨ÙˆØ±Ø¯":
        await message_context.reply(
            "Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø¨Ø³ØªÙ‡ Ø´Ø¯.",
            chat_keypad_type="Removed"
        )
        logger.info("Handled 'Ø¨Ø³ØªÙ† Ú©ÛŒØ¨ÙˆØ±Ø¯' click and removed keyboard.")
        return

    # Default echo for other text messages
    response_text = f"Ø´Ù…Ø§ Ú¯ÙØªÛŒØ¯: '{message_context.text}'"
    await message_context.reply(response_text)
    logger.info(f"Echoed message: '{response_text}'")

# --- Run the Bot ---
if __name__ == "__main__":
    logger.info("Starting Reply Keyboard example bot...")
    asyncio.run(bot.run())
```
---
### ğŸš€ Advanced Features Example

This example demonstrates the integration of advanced inline keyboard types (like textbox, selection, and calendar) and their respective `on_callback` handling.

**`advanced_features_bot_example.py`**
```python
import asyncio
from rubika_bot_api.api import Robot
from rubika_bot_api import filters
from rubika_bot_api.keyboards import InlineKeyboardBuilder # Now with advanced button methods
from rubika_bot_api.logger import logger, debugging

# --- Configuration ---
RUBIKA_TOKEN = "YOUR_RUBIKA_BOT_TOKEN" 
debugging(True) # Enable logging for this example
bot = Robot(token=RUBIKA_TOKEN)

# --- Message Handler ---
@bot.on_message(filters=filters.pv & filters.text) # Only private text messages
async def handle_advanced_keyboard_demo(robot_client, received_message):
    logger.info(f"Received text from PV: '{received_message.text}' from {received_message.sender_id}")

    if received_message.text == "/advanced_keyboard":
        # Example items for selection button
        selection_items = [
            {"text": "Ú¯Ø²ÛŒÙ†Ù‡ Ø§ÙˆÙ„", "image_url": ""}, # image_url is optional
            {"text": "Ú¯Ø²ÛŒÙ†Ù‡ Ø¯ÙˆÙ…"},
            {"text": "Ú¯Ø²ÛŒÙ†Ù‡ Ø³ÙˆÙ…"}
        ]

        # Build an inline keyboard with various advanced button types
        advanced_keyboard = InlineKeyboardBuilder() \
            .row(InlineKeyboardBuilder.button_textbox(text="ğŸ“ Ù†Ø§Ù… Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯", button_id="demo_textbox", title="ÙˆØ±ÙˆØ¯ Ù†Ø§Ù…", place_holder="Ù†Ø§Ù… Ø´Ù…Ø§...")) \
            .row(InlineKeyboardBuilder.button_selection(text="ğŸ“Š Ø§Ù†ØªØ®Ø§Ø¨ Ø§Ø² Ù„ÛŒØ³Øª", button_id="demo_selection", selection_id="my_demo_list", items=selection_items, title="ÛŒÚ©ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯")) \
            .row(InlineKeyboardBuilder.button_calendar(text="ğŸ“… ØªØ§Ø±ÛŒØ® ØªÙˆÙ„Ø¯", button_id="demo_calendar", calendar_type="DatePersian", title="Ø§Ù†ØªØ®Ø§Ø¨ ØªØ§Ø±ÛŒØ®")) \
            .row(InlineKeyboardBuilder.button_number_picker(text="ğŸ”¢ Ø§Ù†ØªØ®Ø§Ø¨ Ø³Ù†", button_id="demo_number_picker", min_value="18", max_value="99", title="Ø³Ù†ØªØ§Ù† Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯")) \
            .row(InlineKeyboardBuilder.button_string_picker(text="ğŸ“ Ø±Ø´ØªÙ‡ ØªØ­ØµÛŒÙ„ÛŒ", button_id="demo_string_picker", items=["Ø±ÛŒØ§Ø¶ÛŒ", "ØªØ¬Ø±Ø¨ÛŒ", "Ø§Ù†Ø³Ø§Ù†ÛŒ"], title="Ø±Ø´ØªÙ‡ ØªØ­ØµÛŒÙ„ÛŒ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯")) \
            .row(InlineKeyboardBuilder.button_location(text="ğŸ“ Ù…Ú©Ø§Ù† Ù…Ù†", button_id="demo_location_picker", title="Ø§Ø´ØªØ±Ø§Ú©\u200cÚ¯Ø°Ø§Ø±ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù…Ú©Ø§Ù†ÛŒ")) \
            .build()
        
        await received_message.reply(
            "Ù„Ø·ÙØ§Ù‹ ÛŒÚ©ÛŒ Ø§Ø² Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø²ÛŒØ± Ø±Ø§ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯:",
            inline_keypad=advanced_keyboard
        )
        logger.info("Sent advanced keyboard demo.")
        return

    # Default echo for other text messages
    response_content = f"Ø´Ù…Ø§ Ú¯ÙØªÛŒØ¯: '{received_message.text}'"
    await received_message.reply(response_content)
    logger.info(f"Echoed message: '{response_content}'")

# --- Callbacks for Advanced Buttons ---
@bot.on_callback("demo_textbox")
async def handle_demo_textbox(robot_client, message_context):
    user_input = message_context.aux_data.start_id # For textbox, submitted text is typically in aux_data.start_id
    user_name = await robot_client.get_name(message_context.sender_id) or "Ú©Ø§Ø±Ø¨Ø±"
    await message_context.reply(f"âœ… {user_name} Ø¹Ø²ÛŒØ²ØŒ Ù†Ø§Ù… Ø´Ù…Ø§: {user_input} Ø«Ø¨Øª Ø´Ø¯.")
    logger.info(f"Handled textbox input from {user_name}: {user_input}")

@bot.on_callback("demo_selection")
async def handle_demo_selection(robot_client, message_context):
    # For selection, raw_data.get('inline_message', {}).get('aux_data', {}).get('selected_items', []) usually holds the selection
    selected_items_raw = message_context.raw_data.get('inline_message', {}).get('aux_data', {}).get('selected_items', [])
    selected_texts = [item.get('text', 'N/A') for item in selected_items_raw]
    
    user_name = await robot_client.get_name(message_context.sender_id) or "Ú©Ø§Ø±Ø¨Ø±"
    await message_context.reply(f"âœ… {user_name} Ø¹Ø²ÛŒØ²ØŒ Ø´Ù…Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯ÛŒØ¯: {', '.join(selected_texts)}")
    logger.info(f"Handled selection from {user_name}: {selected_texts}")

@bot.on_callback("demo_calendar")
async def handle_demo_calendar(robot_client, message_context):
    selected_date = message_context.aux_data.start_id # Date is typically in aux_data.start_id
    user_name = await robot_client.get_name(message_context.sender_id) or "Ú©Ø§Ø±Ø¨Ø±"
    await message_context.reply(f"âœ… {user_name} Ø¹Ø²ÛŒØ²ØŒ ØªØ§Ø±ÛŒØ® Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡: {selected_date} Ø«Ø¨Øª Ø´Ø¯.")
    logger.info(f"Handled calendar date from {user_name}: {selected_date}")

@bot.on_callback("demo_number_picker")
async def handle_demo_number_picker(robot_client, message_context):
    selected_number = message_context.aux_data.start_id # Number is typically in aux_data.start_id
    user_name = await robot_client.get_name(message_context.sender_id) or "Ú©Ø§Ø±Ø¨Ø±"
    await message_context.reply(f"âœ… {user_name} Ø¹Ø²ÛŒØ²ØŒ Ø¹Ø¯Ø¯ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡: {selected_number} Ø«Ø¨Øª Ø´Ø¯.")
    logger.info(f"Handled number picker from {user_name}: {selected_number}")

@bot.on_callback("demo_string_picker")
async def handle_demo_string_picker(robot_client, message_context):
    selected_string = message_context.aux_data.start_id # String is typically in aux_data.start_id
    user_name = await robot_client.get_name(message_context.sender_id) or "Ú©Ø§Ø±Ø¨Ø±"
    await message_context.reply(f"âœ… {user_name} Ø¹Ø²ÛŒØ²ØŒ Ø±Ø´ØªÙ‡ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡: {selected_string} Ø«Ø¨Øª Ø´Ø¯.")
    logger.info(f"Handled string picker from {user_name}: {selected_string}")

@bot.on_callback("demo_location_picker")
async def handle_demo_location_picker(robot_client, message_context):
    # Location data comes in message.location object for location buttons
    if message_context.location:
        user_name = await robot_client.get_name(message_context.sender_id) or "Ú©Ø§Ø±Ø¨Ø±"
        await message_context.reply(f"âœ… {user_name} Ø¹Ø²ÛŒØ²ØŒ Ù…Ú©Ø§Ù† Ø´Ù…Ø§: Ø¹Ø±Ø¶ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ {message_context.location.latitude}, Ø·ÙˆÙ„ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ {message_context.location.longitude}")
        logger.info(f"Handled location from {user_name}: Lat={message_context.location.latitude}, Lon={message_context.location.longitude}")
    else:
        await message_context.reply("Ù…Ú©Ø§Ù† Ø´Ù…Ø§ Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯.")
        logger.warning(f"Location callback received without location data from {message_context.sender_id}.")


# --- Run the Bot ---
if __name__ == "__main__":
    logger.info("Starting advanced features demo bot...")
    asyncio.run(bot.run())


```

--- 
### âœ¨ another simple bot for info and ...
```python
import asyncio
import random
import datetime
import pytz
from rubika_bot_api.api import Robot
from rubika_bot_api import filters
from rubika_bot_api.keyboards import ChatKeyboardBuilder, InlineKeyboardBuilder
from rubika_bot_api.logger import logger, debugging

# --- Configuration ---
RUBIKA_TOKEN = "TOKEN" 

# debugging(True)

bot = Robot(token=RUBIKA_TOKEN)

# --- Interesting Data ---
FUN_FACTS = [
    "Ø¢ÛŒØ§ Ù…ÛŒ\u200cØ¯Ø§Ù†Ø³ØªÛŒØ¯ Ø²Ù†Ø¨ÙˆØ±Ù‡Ø§ Ø¨Ø±Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ ÛŒÚ© Ù‚Ø§Ø´Ù‚ Ú†Ø§ÛŒ\u200cØ®ÙˆØ±ÛŒ Ø¹Ø³Ù„ØŒ Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ Ø§Ø² Û² Ù…ÛŒÙ„ÛŒÙˆÙ† Ú¯Ù„ Ø±Ø§ Ù…Ù„Ø§Ù‚Ø§Øª Ú©Ù†Ù†Ø¯ØŸ",
    "Ø¢ÛŒØ§ Ù…ÛŒ\u200cØ¯Ø§Ù†Ø³ØªÛŒØ¯ ØªÙ†Ù‡Ø§ Ø­ÛŒÙˆØ§Ù†ÛŒ Ú©Ù‡ Ù†Ù…ÛŒ\u200cØªÙˆØ§Ù†Ø¯ Ø¨Ù¾Ø±Ø¯ØŒ ÙÛŒÙ„ Ø§Ø³ØªØŸ",
    "Ø¢ÛŒØ§ Ù…ÛŒ\u200cØ¯Ø§Ù†Ø³ØªÛŒØ¯ Ø²Ø¨Ø§Ù† Ø¢ÙØªØ§Ø¨\u200cÙ¾Ø±Ø³Øª Ø¯Ùˆ Ø¨Ø±Ø§Ø¨Ø± Ø·ÙˆÙ„ Ø¨Ø¯Ù† Ø§ÙˆØ³ØªØŸ",
    "Ø¢ÛŒØ§ Ù…ÛŒ\u200cØ¯Ø§Ù†Ø³ØªÛŒØ¯ Ø§Ø«Ø± Ø§Ù†Ú¯Ø´Øª Ù‡Ø± ÙØ±Ø¯ØŒ Ù…Ù†Ø­ØµØ± Ø¨Ù‡ ÙØ±Ø¯ Ø§Ø³Øª Ùˆ Ø­ØªÛŒ Ø¯ÙˆÙ‚Ù„ÙˆÙ‡Ø§ÛŒ Ù‡Ù…Ø³Ø§Ù† Ù‡Ù… Ø§Ø«Ø± Ø§Ù†Ú¯Ø´Øª Ù…ØªÙØ§ÙˆØª Ø¯Ø§Ø±Ù†Ø¯ØŸ",
    "Ø¢ÛŒØ§ Ù…ÛŒ\u200cØ¯Ø§Ù†Ø³ØªÛŒØ¯ Ù‚Ù„Ø¨ Ù…ÛŒÚ¯Ùˆ Ø¯Ø± Ø³Ø±Ø´ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ø¯ØŸ"
]

# --- Bot Start Handler ---
@bot.on_started_bot()
async def on_bot_start(bot_instance, chat_id):
    logger.info(f"Bot started by chat_id: {chat_id}")
    main_keyboard = ChatKeyboardBuilder(resize=True, on_time=False).row("/fact", "/time").row("/myinfo", "/about").build()
    await bot_instance.send_message(
        chat_id=chat_id,
        text="Hello! Welcome to the bot. Use the keyboard below for commands:",
        chat_keypad=main_keyboard,
        chat_keypad_type="New"
    )

# --- Bot Stop Handler ---
@bot.on_stopped_bot()
async def on_bot_stop(robot, chat_id):
    logger.info(f"Bot stopped by chat_id: {chat_id}")
    # In a real bot, you might perform cleanup here.

# --- Main Message Handler (All logic unified here) ---
@bot.on_message(filters=filters.pv & filters.text) # Only process private text messages
async def handle_all_pv_text_messages(bot_instance, message_context):
    logger.info(f"Received text from PV: '{message_context.text}' from {message_context.sender_id}")

    # --- Check for specific commands first ---
    if message_context.text == "/fact":
        fact = random.choice(FUN_FACTS)
        await message_context.reply(f"ğŸ’¡ Ø­Ù‚ÛŒÙ‚Øª Ø¬Ø§Ù„Ø¨: \n{fact}")
        logger.info(f"Sent fun fact to {message_context.sender_id}")
        return # Important: Return after handling a command

    elif message_context.text == "/time":
        try:
            tehran_tz = pytz.timezone('Asia/Tehran')
            now_tehran = datetime.datetime.now(tehran_tz)
            time_str = now_tehran.strftime("%Y-%m-%d %H:%M:%S")
            await message_context.reply(f"â° Ø³Ø§Ø¹Øª ÙØ¹Ù„ÛŒ Ø¯Ø± ØªÙ‡Ø±Ø§Ù†: {time_str}")
        except Exception as e:
            logger.error(f"Error getting time: {e}")
            await message_context.reply("Ù…ØªØ§Ø³ÙÙ…ØŒ Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± Ù†Ù…Ø§ÛŒØ´ Ø³Ø§Ø¹Øª Ø±Ø® Ø¯Ø§Ø¯.")
        logger.info(f"Sent time to {message_context.sender_id}")
        return # Important: Return after handling a command

    elif message_context.text == "/myinfo":
        user_id = message_context.sender_id
        user_name = await bot_instance.get_name(user_id)
        user_username = await bot_instance.get_username(user_id)
        
        info_text = f"ğŸ‘¤ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ù…Ø§:\n" \
                    f"Ù†Ø§Ù…: {user_name or 'Ù†Ø§Ù…ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯'}\n" \
                    f"ÛŒÙˆØ²Ø±Ù†ÛŒÙ…: @{user_username or 'ÛŒØ§ÙØª Ù†Ø´Ø¯'}\n" \
                    f"Ø´Ù†Ø§Ø³Ù‡ Ú©Ø§Ø±Ø¨Ø±ÛŒ: `{user_id}`"
        await message_context.reply(info_text)
        logger.info(f"Sent user info to {message_context.sender_id}")
        return # Important: Return after handling a command

    elif message_context.text == "/about":
        await message_context.reply("Ù…Ù† ÛŒÚ© Ø±Ø¨Ø§Øª Ù†Ù…ÙˆÙ†Ù‡ Ù‡Ø³ØªÙ… Ú©Ù‡ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ Rubika Bot API Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡â€ŒØ§Ù….")
        logger.info(f"Sent about info to {message_context.sender_id}")
        return # Important: Return after handling a command

    # --- Handle reply keyboard buttons (text matches) ---
    elif message_context.text == "Ø¨Ø§Øª Ø¬Ø¯ÛŒØ¯":
        # Create an inline button to confirm
        inline_btn = InlineKeyboardBuilder.button(
            text="âœ… ØªØ§ÛŒÛŒØ¯ Ø³Ø§Ø®Øª Ø¨Ø§Øª",
            button_id="confirm_new_bot"
        )
        inline_keyboard = InlineKeyboardBuilder().row(inline_btn).build()
        await message_context.reply(
            "Ø¢ÛŒØ§ Ø§Ø² Ø³Ø§Ø®Øª Ø¨Ø§Øª Ø¬Ø¯ÛŒØ¯ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø¯Ø§Ø±ÛŒØ¯ØŸ",
            inline_keypad=inline_keyboard
        )
        return

    elif message_context.text == "Ù„ÛŒØ³Øª Ø¨Ø§Øªâ€ŒÙ‡Ø§":
        await message_context.reply(f"{user_name or 'Ú©Ø§Ø±Ø¨Ø±'} Ø¹Ø²ÛŒØ²ØŒ Ù‡Ù†ÙˆØ² Ø¨Ø§ØªÛŒ Ø¨Ø±Ø§ÛŒ Ø´Ù…Ø§ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.")
        return
    
    elif message_context.text == "Ø¨Ø³ØªÙ† Ú©ÛŒØ¨ÙˆØ±Ø¯":
        await message_context.reply(
            "Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø¨Ø³ØªÙ‡ Ø´Ø¯.",
            chat_keypad_type="Removed" # "Removed" hides the keyboard
        )
        logger.info("Hidden Reply Keyboard.")
        return

    # --- Handle inline button clicks (aux_data) ---
    if message_context.aux_data and message_context.aux_data.button_id:
        button_id = message_context.aux_data.button_id
        
        if button_id == "confirm_new_bot":
            user_name = await bot_instance.get_name(message_context.sender_id) or "Ú©Ø§Ø±Ø¨Ø±"
            await message_context.reply(f"âœ… {user_name} Ø¹Ø²ÛŒØ²ØŒ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø³Ø§Ø®Øª Ø¨Ø§Øª Ø´Ù…Ø§ Ø«Ø¨Øª Ø´Ø¯!")
            logger.info(f"Handled inline button click: 'confirm_new_bot' by {user_name}.")
            return

        # Add other inline button handlers here if needed (e.g., from AI feature)
        # elif button_id.startswith("reprocess_text:"): ...
        # elif button_id.startswith("say_hello"): ...

        # Fallback for unhandled inline buttons
        else:
            await message_context.reply(f"â‰ï¸ Ø¯Ú©Ù…Ù‡ Ù†Ø§Ø´Ù†Ø§Ø®ØªÙ‡ Ú©Ù„ÛŒÚ© Ø´Ø¯: {button_id}")
            logger.info(f"Unhandled inline button click: {button_id}")
            return
    
    # --- Default echo for general text messages if no command or button matched ---
    response_content = f"Ø´Ù…Ø§ Ú¯ÙØªÛŒØ¯: '{message_context.text}'\nØ¨Ø±Ø§ÛŒ Ø¯ÛŒØ¯Ù† Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§ØŒ Ø¯Ø³ØªÙˆØ±Ø§Øª Ø²ÛŒØ± Ø±Ø§ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯:\n/fact, /time, /myinfo, /about"
    await message_context.reply(response_content)
    logger.info(f"Echoed general message: '{response_content}'")


# --- Run the Bot ---
if __name__ == "__main__":
    logger.info("Starting asynchronous Rubika bot example with unified handlers...")
    asyncio.run(bot.run())
```
